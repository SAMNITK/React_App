Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var framerMotion = require('framer-motion');
var reactIntersectionObserver = require('react-intersection-observer');

/**
 * `useInViewAnimate` starts a specified animation when the element becomes visible
 *
 * @param variants - Motion Variants
 *
 * @returns inViewRef
 * @returns animationControls
 */
var useInViewAnimate = function (_a, options) {
    var initial = _a.initial, animate = _a.animate;
    if (options === void 0) { options = {}; }
    var animation = framerMotion.useAnimation();
    var _b = reactIntersectionObserver.useInView(options), inViewRef = _b[0], inView = _b[1];
    react.useEffect(function () {
        if (initial)
            animation.set(initial);
    }, []);
    react.useEffect(function () {
        if (inView) {
            animation.start(animate);
        }
        else if (initial && options.triggerOnce === false) {
            animation.start(initial);
        }
    }, [inView]);
    return { inViewRef: inViewRef, animation: animation };
};

/**
 * `useInViewScroll` returns a MotionValue that updates when the target element is visible in viewport
 *
 * @param el - The target element
 * @param options - An object of options e.g. `threshold`
 */
var useInViewScroll = function (el, options) {
    if (options === void 0) { options = {}; }
    var progress = framerMotion.useMotionValue(0);
    var scrollY = framerMotion.useViewportScroll().scrollY;
    react.useEffect(function () {
        var handleScrollProgress = function () {
            var node = el.current;
            if (!node)
                return;
            var threshold = options.threshold || 0;
            var elPosY = node.getBoundingClientRect().top + scrollY.get();
            var elHeight = node.scrollHeight;
            var viewIntersect = Math.max(elPosY - window.innerHeight, 0);
            var current = scrollY.get() - viewIntersect - threshold;
            var total = Math.min(window.innerHeight, elPosY) + elHeight - threshold;
            var quotient = current / total;
            if (quotient > 0 && quotient < 1) {
                progress.set(quotient);
            }
        };
        var unsubscribeFromScroll = scrollY.onChange(handleScrollProgress);
        return function () { return unsubscribeFromScroll(); };
    }, []);
    return progress;
};

/**
 * `useMotionAsState` returns a React state that updates when the MotionValue changes
 *
 * @param motionValue - MotionValue
 */
var useMotionAsState = function (motionValue) {
    var _a = react.useState(), state = _a[0], setState = _a[1];
    react.useEffect(function () {
        var handleChange = function () { return setState(motionValue.get()); };
        var unsubscribe = motionValue.onChange(handleChange);
        return function () { return unsubscribe(); };
    }, []);
    return state;
};

/**
 * `useStateAsMotion` returns a MotionValue that updates when the React state changes
 *
 * @param state - React state
 */
var useStateAsMotion = function (state) {
    var motionValue = framerMotion.useMotionValue(state);
    react.useEffect(function () {
        motionValue.set(state);
    }, [state]);
    return motionValue;
};

exports.useInViewAnimate = useInViewAnimate;
exports.useInViewScroll = useInViewScroll;
exports.useMotionAsState = useMotionAsState;
exports.useStateAsMotion = useStateAsMotion;
//# sourceMappingURL=index.js.map
